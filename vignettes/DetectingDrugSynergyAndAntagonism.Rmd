---
title: "Detecting Drug Synergy and Antagonism with PharmacoGx 3.0+"
author:
- name: Christopher Eeles
  affiliation: &pm Princess Margaret Cancer Centre, University Health Network, Toronto Canada
  email: christopher.eeles@uhnresearch.ca
- name: Feifei Li
  affiliation: &ccb Department of Cell & System Biology, University of Toronto, Toronto Canada
- name: Petr Smirnov
  affiliation:
    - *pm
    - &mbp Department of Medical Biophysics, University of Toronto, Toronto Canada
  email: psmirnov@utoronto.ca
- name: Benjamin Haibe-Kains
  affiliation:
    - *pm
    - *mbp
  email: benjamin.haibe.kains@utoronto.ca
output:
  BiocStyle::html_document
abstract: |
  Drug combinations are an effective strategy to over come incomplete response
  or acquired resistance to monotherapies in clinical oncology and beyond. As
  such, detecting molecular signatures of drug synergy or antagonism in
  pre-clinical model systems is a major priority to accelerate the adoption of
  novel treatment strategies in the clinic. The release of PharmacoGx 3.0
  introduces support for storing, analyzing and visualizing the results of drug
  combination experiments using the PharmacoSet class, and will enable
  reseachers across a range of disciplines to more easily mine the published
  drug combination literature for promising molecular signatures of synergy or
  antagonism which can be validated in retrospective patient data and prioritized
  for prospective clinical trails.
bibliography: drugCombos.bib
vignette: |
  %\VignetteIndexEntry{Detecting Drug Synergy and Antagonism with PharmacoGx 3.0+}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r eval=TRUE, include=FALSE}
cgx <- BiocStyle::Biocpkg("CoreGx")
pgx <- BiocStyle::Biocpkg("PharmacoGx")
```

# Synergy/Antagonism Biomarker Discovery

For a comprehensive introduction to detecting biomarkers of drug synergy or
antagonism with `r cgx` and `r pgx`, please see our
[workshop from BioC2022](http://bhklab.ca/bioc2022workshop/articles/PGxWorkshop.html).

# Mathews Griner

The Mathews Griner dataset was generated in a high-throughput drug combination
screening study conducted to explore potential drug synergies and antagonisms
in a panel of 459 compounds combined with the Tyrosine Kinase inhibitor
ibrutinib in cancer cell lines from the activated B-cell like subtype of diffuse
large B-cell lymphoma [@mathewsgrinerHighthroughputCombinatorialScreening2014].
The study uses a 6 x 6 combination matrix design, where each respective drug in
a combination undergoes a 4-fold dilution series over 4 steps, with the last
well left untreated. This can be conceptualized as drug combination matrix where
the final row and column represent monotherapy experiments for each compound in
the pair. A total of 36 viability measurements were taken via the CellTitreGlo
assay for each drug pair, being comprised of pair-wise combinations of each
dose level in the respective dilution series matrix.

We selected this dataset for our vignette to simplify comparison with the
`SynergyFinder` package, which was previously used to analyze this dataset
[@yadavSearchingDrugSynergy2015].

```{r load_dependencies_eval, eval=TRUE, echo=FALSE}
suppressPackageStartupMessages({
    library(PharmacoGx)
    library(CoreGx)
    library(data.table)
    library(ggplot2)
})
```

```{r load_dependencies_echo, eval=FALSE, echo=TRUE}
library(PharmacoGx)
library(CoreGx)
library(data.table)
library(ggplot2)
```


## Reading in Raw Data

We have included a compressed CSV version of the Mathews Griner dataset
which we curated to have informative compound names. You can read the file
in with your CSV reader of choice.

```{r}
input_file <- file.path("mathews_griner.csv.tar.gz")
mathews_griner <- fread(input_file)
```

## Experimental Design Hypothesis

Before modelling dose-response or treatment synergy/antagonism with `r pgx` we
must first build a `TreatmentResponseExperiment` from our high-throughput
drug combination data. This S4 class was designed to store and analyze high
dimensional treatment response data, such as the dose-response screens in cancer
cell lines which are the subject of this analysis. For a detailed explanation
of the class design, please refer to the
[TreatmentResponseExperiment vignette in CoreGx](http://bhklab.ca/CoreGx/articles/TreatmentResponseExperiment.html).

Due to the highly diverse set of experimental designs used in drug combination
studies, the first step in any drug combination analysis is to generate a
hypothesis about the study design. For the `TreatmentResponseExperiment`,
we must identify which columns in our raw data are required to uniquely
identify every treatment (our rows), sample (our columns) and observation
(our assays). As a starting point we recommend trying treatment identifiers and
their respective doses for rows, sample identifiers for columns, and the union
of these for observations.^[Giving names to columns in your group list will
automatically rename them when the `TreatmentResponseExperiment` gets created!]

```{r experiment_design_hypothesis}
groups <- list(
    rowDataMap=c(
        treatment1id="RowName", treatment2id="ColName",
        treatment1dose="RowConcs", treatment2dose="ColConcs"
    ),
    colDataMap=c("sampleid")
)
groups[["assayMap"]] <- c(groups$rowDataMap, groups$colDataMap)
(groups)
```

## Handling Undocumented Replicates

These initial guesses can be insufficient to uniquely identify our
treatments or samples if there are technical or biological replicates in the
data. While some publications are explicit about the presence of such
measurements, others are not and require us to explore the data to identify
them. In general, we recommend undocumented replicates be treated as technical
and used to quantify noise in the assay unless there is a good reason to believe
they are from distinct biological entities.

We can identify undocumented replicates using a "group by" operation. This
operation uses the split-apply-combine strategy (also called Map-Reduce) to
compute some aggregation over subsets of a `data.frame`. A grouping has
undocumented replicates if more than one row is assigned to any group which we
hypothesized to uniquely identify the observations in our data. We check this
below using the `.N` special variable from the `data.table` package, which
counts the number of instances in each group defined by the column in `by`.
Similar operations could be accomplished with `dplyr` or even base R, though
they may be slower and have less concise syntax.

```{r handling_technical_replicates}
# The := operator modifies a data.table by reference (i.e., without making a copy)
mathews_griner[, tech_rep := seq_len(.N), by=c(groups[["assayMap"]])]
if (max(mathews_griner[["tech_rep"]]) > 1) {
    groups[["colDataMap"]] <- c(groups[["colDataMap"]], "tech_rep")
    groups[["assayMap"]] <- c(groups[["assayMap"]], "tech_rep")
} else {
    # delete the additional column if not needed
    message("No technical replicates in this dataset!")
    mathews_griner[["tech_reps"]] <- NULL
}
```

For the Mathews Griner dataset, we do indeed have undocumented replicates!

## Using the `TREDataMapper`

Once we are confident we know which columns are needed to uniquely
identify our treatments and samples, we can create a `TREDataMapper` using
our raw data and mapping hypothesis. The `TREDataMapper` is a helper class
designed to make creating a `TreatmentResponseExperiment` from diverse drug
combination experimental designs easier for users.

The `guessMapping` method does the necessary internal work to map additional
columns in your dataset to the appopriate category&mdash;treatment metadata,
sample metadata or assay data&mdash;and returns the column names for each group
in the "mapped_columns" list item.

```{r build_tredatamapper}
(treMapper <- TREDataMapper(rawdata=mathews_griner))
```

We will know we have successfully mapped all of our data if the "unmapped" list
item in our guess has no columns names in it. If this is not the case, you
may have to refine your hypothesis to include additional information needed
to uniquely identify each observation in your dataset.^[The metadata item in
the list returned from `guessMapping` captures all columns in our dataset which
only have one unique value. These can be assigned to the `metadata` slot of
the `TreatmentResponseExperiment` to make our object smaller in memory.]

```{r evaluate_tre_mapping_guess}
(guess <- guessMapping(treMapper, groups, subset=TRUE))
```

Once we have mapped all our columns, we can assign their names to the
`TREDataMapper` object and use it to construct the `TreatmentResponseExperiment`
we will use in downstream dose-response and synergy-antagonism modelling.^[We
need to give names to the metadataMap and assayMap for in the `TREDataMapper`,
since there can be more than one item in each of these slots of a
`TreatmentResponseExperiment`.]

```{r update_tredatamapper_with_guess}
metadataMap(treMapper) <- list(experiment_metadata=guess$metadata$mapped_columns)
rowDataMap(treMapper) <- guess$rowDataMap
colDataMap(treMapper) <- guess$colDataMap
assayMap(treMapper) <- list(raw=guess$assayMap)
treMapper
```

## Creating a `TreatmentResponseExperiment`

`r pgx` includes the `metaConstruct` method to simplify creation of a
`TreatmentResponseExperiment` object. Simply call it on the `TREDataMapper` you
created previously to instantiate the object.

```{r metaconstruct_the_tre}
(tre <- metaConstruct(treMapper))
```

## Normalizing Treatment Response

The viability measurements in the Mathews Griner data have already been
normalized relative to the time zero control. However, `r pgx` recommends
further normalizing against the untreated control to limit the range
of your viability measurements to be close to [0, 1]. The untreated control
is the well which has only been treated with the drug delivery vehicle (usually
the solvent DMSO) and has thus been allowed to grow over the treatment exposure
time.

To accomplish this for our current dataset, we can use a sub-query where we
select the viability at index (6, 6) of our drug combination matrix. This is
well has not been treatment with either drug. Dividing by it normalizes the
observed viability in our treatment wells relative to any growth that may
have occured during treatment. We further truncate our viability values at
zero, since any values below this are likely a result of technical noise in our
assay.^[The `.SD` special variable, short for "subset data", is a `data.table`
feature that allows you to implement complex sub-queries. It contains a copy
of the entire `data.table` object you are querying.]

```{r normalize_to_dose_0_0_control}
raw <- tre[["raw"]]
raw[,
    viability := viability / .SD[treatment1dose == 0 & treatment2dose == 0, viability],
    by=c("treatment1id", "treatment2id", "sampleid", "tech_rep")
]
raw[, viability := pmax(0, viability)]  # truncate min viability at 0
tre[["raw"]] <- raw
```

As a sanity check that our normalization was effective, we have a look at the
range of our viabiltiy values. In most cases, this should be very close to
[0, 1], since we do not expect treatment with one or more compound to increase
the growth of our cell lines.

```{r sanity_check_viability}
tre[["raw"]][, range(viability)]
```

Some of our treated viabilties are >60x higher than our control! This is very
unlikely to be a real signal and probably indicates there was an issue
with the viability measurement for our dose 0 x 0 well. To quality control
our results, we will find the treatment combination with this observation
and remove it from downstream analysis. It is always essential to perform
regular sanity checks to ensure your data is plausible given the experimental
setup.

```{r find_bad_viability_treatment}
(bad_treatments <- tre[["raw"]][viability > 2, unique(treatment1id)])
```

Only a single treatment has a viability measurement higher than twice our
control. We will remove this and leave the remaining values in place, since
we can simply truncate them at vaiblity of 1 to include as many combinations
in our analyses as possible.

```{r remove_bad_viability_treatment}
(tre <- subset(tre, !(treatment1id %in% bad_treatments)))
```

We will inspect the viability range again to ensure the bad data has
been removed.

```{r sanity_check_viability2}
tre[["raw"]][, range(viability)]
```

The range for viabilities is now much more reasonable, and we can move on
to fitting dose-response curves to our monotherapy measurements.

## Fitting Monotherapy Curves

The `endoaggregate` method allows us to extract an assay from our
`TreatmentResponseExperiment`, compute a group by (aggregation) over it,
then assign it back to our `TreatmentResponseExperiment` via a join. Since we
currently only want to fit curves to the monotherapy experiments
in our drug matrix we will use the `subset` argument to filter the assay
to only monotherapy rows before applying the aggregation.

The `endoaggregate` method is useful to update existing assays, or to create
new ones. The `assay` argument specifies the assay to aggregate over and the
`target` argument specifies the name of the assay to assign the results to.
If the `target` does not already exist, a new assay will be created otherwise
the specified `target` will be updated. If you exclude this argument, the
`assay` you select automatically becomes the `target`. The `endoaggregate`
method is endomorphic, which are a class of methods that always return
the same type they are called on. This means that `endoaggregate` always
returns a new `TreatmentResponseExperiment`.

While subsetting out our monotherapy viabilities, we can also summarize
viabilities over our techinical replicates by excluding that column from our
`by` argument. Any additional arguments to `endoaggregate` via `...` are
assumed to be aggregation calls and will be computed for each group
identified in `by` and assigned to `target`. The name given to any argument
in `...` will be the column name for that computation in the resulting
`TreatmentResponseExperiment`.

```{r creating_monotherapy_assay}
tre_qc <- tre |>
    endoaggregate(
        subset=treatment2dose == 0,  # filter to only monotherapy rows
        assay="raw",
        target="mono_viability",  # create a new assay named mono_viability
        mean_viability=pmin(1, mean(viability)),
        by=c("treatment1id", "treatment1dose", "sampleid")
    )
```

Once we have isolated our monotherapy viabilities, we can once again use
`endoaggregate` to fit our dose-response curves. This time we will use the
`enlist=FALSE` option which allows us to assign intermediate variables
during our aggregation. Pass in an entire code block to `endoggregate`
to use this feature and only the each named item of the returned list will
become a column in your `target` assay. To prevent repeating our curve
parameters, we will create a new assay for them since we are now summarizing
over dose.

```{r monotherapy_curve_fits}
tre_fit <- tre_qc |>
    endoaggregate(
        {
            fit <- logLogisticRegression(treatment1dose, mean_viability,
                viability_as_pct=FALSE)
            ic50 <- computeIC50(treatment1dose, Hill_fit=fit)
            aac <- computeAUC(treatment1dose, Hill_fit=fit)
            list(  # each list time will be a column in the target assay
                HS=fit[["HS"]],
                E_inf = fit[["E_inf"]],
                EC50 = fit[["EC50"]],
                Rsq=as.numeric(unlist(attributes(fit))),
                aac_recomputed=aac,
                ic50_recomputed=ic50
            )
        },
        assay="mono_viability",
        target="mono_profiles",
        enlist=FALSE,
        by=c("treatment1id", "sampleid"),
        nthread=2
    )
```

## Joining Monotherapy Curve Fits to Combinations

Since we require the monotherapy curve parameters to calculate dose-response
dependent synergy metrics such as Loewe and ZIP, we will add these to a
a new drug combination assay to make computing synergy metrics possible with
`endoaggregate`.

```{r create_combo_viability}
tre_combo <- tre_fit |>
    endoaggregate(
        assay="raw",
        target="combo_viability",
        mean(viability),
        by=c("treatment1id", "treatment2id", "treatment1dose", "treatment2dose",
            "sampleid")
    )
```

The `mergeAssays` method is a convenient way to perform joins between the
assays of a `TreatmentResponseExperiment` endomorphically. It is equivalent
to extracting the assays from the object, performing a join using the `merge`
command, and assigning back to the assay specified as the `x` argument. This
method accepts all the same parameters as the `data.table::merge` method,
but requires the assays in `x` and `y` be specified as assay name instead of
actual assay tables.^[The endomorphic nature of this operation allows the
result to be piped into additional calls, as demonstrated below.]

```{r add_monotherapy_fits_to_combo_viability}
tre_combo <- tre_combo |>
    mergeAssays(
        x="combo_viability",
        y="mono_profiles",
        by=c("treatment1id", "sampleid")
    ) |>
    mergeAssays(
        x="combo_viability",
        y="mono_profiles",
        by.x=c("treatment2id", "sampleid"),
        by.y=c("treatment1id", "sampleid"),
        suffixes=c("_1", "_2")
    )
```

The `endoaggregate` method is compatible with all `data.table` syntax, since
`assays` are implemented internally using this package. As such, we can use
a sub-query (via `.SD`) to pull out the viability measurements for each
individual drug in our combination. This value is needed to compute the
Highest Single Agent and Bliss synergy metrics. We will add these values to
our "combo_viability" assay so all the synergy metrics .

```{r }
tre_combo <- tre_combo |>
    endoaggregate(
        viability_1=.SD[treatment2dose == 0, mean_viability],
        assay="combo_viability",
        by=c("treatment1id", "treatment1dose", "sampleid")
    ) |>
    endoaggregate(
        viability_2=.SD[treatment1dose == 0, mean_viability],
        assay="combo_viability",
        by=c("treatment1id", "treatment2dose", "sampleid")
    )
```

Now that we have assembled all the requisite information into the
"combo_viability" assay, we are ready to compute our synergy scores!

## Compute Synergy Scores



```{r compute_synergy_null_hypotheses}
tre_synergy <- tre_combo |>
    endoaggregate(
        assay="combo_viability",
        HSA_ref=computeHSA(viability_1, viability_2),
        Bliss_ref=computeBliss(viability_1, viability_2),
        Loewe_ref=computeLoewe(
            treatment1dose, HS_1=HS_1, EC50_1=EC50_1, E_inf_1=E_inf_1,
            treatment2dose, HS_2=HS_2, EC50_2=EC50_2, E_inf_2=E_inf_2
        ),
        ZIP_ref=computeZIP(
            treatment1dose, HS_1=HS_1, EC50_1=EC50_1, E_inf_1=E_inf_1,
            treatment2dose, HS_2=HS_2, EC50_2=EC50_2, E_inf_2=E_inf_2
        ),
        by=assayKeys(tre_combo, "combo_viability"),
        nthread=2
    )
```

```{r synergy_score_vs_reference}
tre_synergy <- tre_synergy |>
    endoaggregate(
        assay="combo_viability",
        HSA_score=HSA_ref - mean_viability,
        Bliss_score=Bliss_ref - mean_viability,
        Loewe_score=Loewe_ref - mean_viability,
        ZIP_score=ZIP_ref - mean_viability,
        by=assayKeys(tre_synergy, "combo_viability")
    )
```


```{r zip_two_way_fit}
tre_zip <- tre_synergy |>
    endoaggregate(
        assay="combo_viability",
        subset=treatment2dose != 0,
        {
            zip_fit <- estimateProjParams(
                dose_to=treatment1dose,
                combo_viability=mean_viability,
                dose_add=unique(treatment2dose),
                EC50_add=unique(EC50_2),
                HS_add=unique(HS_2),
                E_inf_add=unique(E_inf_2)
            )
            setNames(zip_fit, paste0(names(zip_fit), "_2_to_1"))
        },
        enlist=FALSE,
        by=c("treatment1id", "treatment2id", "treatment2dose", "sampleid"),
        nthread=2
    )
tre_zip <- tre_zip |>
    endoaggregate(
        assay="combo_viability",
        subset=treatment1dose != 0,
        {
            zip_fit <- estimateProjParams(
                dose_to=treatment2dose,
                combo_viability=mean_viability,
                dose_add=unique(treatment1dose),
                EC50_add=unique(EC50_1),
                HS_add=unique(HS_1),
                E_inf_add=unique(E_inf_1)
            )
            setNames(zip_fit, paste0(names(zip_fit), "_1_to_2"))
        },
        enlist=FALSE,
        by=c("treatment1id", "treatment2id", "treatment1dose", "sampleid"),
        nthread=2
    )
```

```{r compute_zip_delta}
tre_zip <- tre_zip |>
    endoaggregate(
        assay="combo_viability",
        ZIP_delta=.deltaScore(
            EC50_1_to_2=EC50_proj_1_to_2, EC50_2_to_1=EC50_proj_2_to_1,
            EC50_1=EC50_1, EC50_2=EC50_2,
            HS_1_to_2=HS_proj_1_to_2, HS_2_to_1=HS_proj_2_to_1,
            HS_1=HS_1, HS_2=HS_2,
            E_inf_1_to_2=E_inf_proj_1_to_2, E_inf_2_to_1=E_inf_proj_2_to_1,
            E_inf_1=E_inf_1, E_inf_2=E_inf_2,
            treatment1dose=treatment1dose, treatment2dose=treatment2dose,
            ZIP=ZIP_ref
        ),
        by=assayKeys(tre_zip, "combo_viability")
    )
```

## Visualizing Drug Synergy

```{r compute_top_synergy}
combo_viab <- tre_zip[["combo_viability"]]
(top_15_combo <- combo_viab[
    Rsq_1 > 0.5 & Rsqr_1_to_2 > 0.5 & Rsqr_2_to_1 > 0.5,
    .(
        max_delta=max(ZIP_delta, na.rm=TRUE),
        mean_delta=mean(ZIP_delta, na.rm=TRUE),
        max_bliss=max(Bliss_score, na.rm=TRUE),
        mean_bliss=mean(Bliss_score, na.rm=TRUE)
    ),
    by=.(treatment1id, treatment2id, sampleid)
][
    order(-max_delta),
    unique(.SD)
][1:15])
```

```{r handle_synergy_missing}
top_15_combo_df <- combo_viab[top_15_combo, on=c('treatment1id', 'treatment2id', 'sampleid')]
# Last observation carried forward for NA/NaN delta scores, to make plot look nicer
setnafill(top_15_combo_df, type="locf", cols="ZIP_delta")
```

```{r synergy_contour_plot}
top_15_combo_df |>
    ggplot(aes(x=treatment1dose, y=treatment2dose, z=ZIP_delta * 100)) +
    scale_x_log10(oob=scales::squish_infinite) +
    scale_y_log10(oob=scales::squish_infinite) +
    geom_contour_filled(
        breaks=c(-100, -80, -40, -20, -10, -1, 1, 10, 20, 40, 80, 100)
    ) +
    facet_wrap(~ treatment1id, nrow=3, ncol=5) +
    scale_fill_brewer(palette="RdBu", direction=-1, drop=FALSE)
```

```{r synergy_heatmap}
top_15_combo_df |>
    ggplot(aes(x=factor(treatment1dose), y=factor(treatment2dose))) +
    geom_tile(aes(fill=ZIP_delta * 100)) +
    facet_wrap(~treatment1id, nrow=3, ncol=5) +
    scale_fill_gradient2(low="blue", mid="white", high="red", midpoint=0)
```

# Session Info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References {.unnumbered}