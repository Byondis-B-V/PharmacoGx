---
title: "Detecting Drug Synergy and Antagnoism with PharmacoGx 3.0"
author:
- name: Christopher Eeles
  affiliation: &pm Princess Margaret Cancer Centre, University Health Network, Toronto Canada
  email: christopher.eeles@uhnresearch.ca
- name: Feifei Li
  affiliation: &ccb Department of Cell & System Biology, University of Toronto, Toronto Canada
- name: Petr Smirnov
  affiliation:
    - *pm
    - &mbp Department of Medical Biophysics, University of Toronto, Toronto Canada
  email: psmirnov@utoronto.ca
- name: Benjamin Haibe-Kains
  affiliation:
    - *pm
    - *mbp
  email: benjamin.haibe.kains@utoronto.ca
output:
  BiocStyle::html_document
abstract: |
  Drug combinations are an effective strategy to over come incomplete response
  or acquired resistance to monotherapies in clinical oncology and beyond. As
  such, detecting molecular signatures of drug synergy or antagonism in
  pre-clinical model systems is a major priority to accelerate the adoption of
  novel treatment strategies in the clinic. The release of PharmacoGx 3.0
  introduces support for storing, analyzying and visualizing the results of drug
  combination experiments using the PharmacoSet class, and will enable
  reseachers across a range of disciplines to more easily mine the published
  drug combination literature for promising signatures of synergy or antagonism
  which can be validated in retrospective patient data and prioritized
  for prospective clinical trails.
bibliography: drugCombos.bib
vignette: |
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r eval=TRUE, include=FALSE}
cgx <- BiocStyle::Biocpkg("CoreGx")
pgx <- BiocStyle::Biocpkg("PharmacoGx")
```

# Drug Combinations Tutorial

For a comprehensive introduction to drug combination modelling with `r cgx` and
`r pgx`, please see our
[workshop from BioC2022](http://bhklab.ca/bioc2022workshop/articles/PGxWorkshop.html).

# Mathews Griner

The Mathews Griner dataset is from a high-throughput drug combination screening
study conducted to explore potential drug synergies, additivities or antagonisms
in a panel of 459 compounds combined with the Tyrosine Kinase inhibitor ibrutinib
in the activated B-cell like subtype of diffuse large B-cell lymphoma
[@mathewsgrinerHighthroughputCombinatorialScreening2014]. The study uses a
6x6 combination matrix design, where each respective drug in a combination
undergoes a 4-fold dilution series over 5 steps, with the 6th step being
untreated. The result is a total of 36 cell viability measurements via The
CellTitreGlo assay 48 hrs after initial treatment. We selected this dataset
for our vignette to simplify comparison with the `SynergyFinder` package,
which was used to analyze the same dataset [@yadavSearchingDrugSynergy2015].

```{r load_dependencies_eval, eval=TRUE, echo=FALSE}
suppressPackageStartupMessages({
    library(PharmacoGx)
    library(CoreGx)
    library(data.table)
    library(ggplot2)
})
```

```{r load_dependencies_echo, eval=FALSE, echo=TRUE}
library(PharmacoGx)
library(CoreGx)
library(data.table)
library(ggplot2)
```


## Reading in Raw Data

We have included a compressed CSV version of the Mathews Griner dataset
which we curated to have informative compound names.

```{r}
input_file <- file.path("mathews_griner.csv.tar.gz")
mathews_griner <- fread(input_file)
```

## Experimental Design Hypothesis

Before modelling dose-response and treatment synergy with `r pgx` we must
first build a `TreatmentResponseExperiment` from our raw high-throughput
drug combination dataset. This S4 class is used to store high-dimensional
treatment response experiments, such as the dose-response screens in cancer
cell lines which are the subject of this analysis. For a detailed explanation
of the class design, please refer to our
[TreatmentResponseExperiment vignette in CoreGx](http://bhklab.ca/CoreGx/articles/TreatmentResponseExperiment.html).

Due to the highly diverse set of experimental designs used in drug combination
studies, the first step in any drug combination analysis is to generate a
hypothesis about the study design. For the `TreatmentResponseExperiment`,
we must identify which columns in our raw data are required to uniquely
identify every treatment (our rows) and sample (our columns). As a starting
point we recommend trying treatment identifiers and their respective doses
for rows and sample identifiers for columns.

```{r}
groups <- list(
    rowDataMap=c(
        treatment1id="RowName", treatment2id="ColName",
        treatment1dose="RowConcs", treatment2dose="ColConcs"
    ),
    colDataMap=c("sampleid")
)
groups[["assayMap"]] <- c(groups$rowDataMap, groups$colDataMap)
(groups)
```

## Handling Undocumented Replicates

These initial guesses can be insufficient to uniquely identify our treatments or
samples if there are technical or biological replicates in the dataset. While
some publications are explicit about these measurements in their datasets, others
are not and require us to explore the data to identify them. In general, We
recommend undocumented replciates be treated as technical replicates and used
to quantify the noisiness of our dataset unless explicitly documented as being
biological replicates.

We can identify undocumented replicates using a group by operation. This
operation used the split-apply-combine paradigm to compute some aggregate
over subsets of tabular data. A group has undocumented replicates if more
than one row is assigned to groups which we hypothesize to uniquely identify
every observation in our data. We check this below using the `.N` special
variable from the `data.table` package, which counts the number of instances
in a each group. Similar operations could be accomplished with `dplyr` or
even base R.

```{r}
mathews_griner[, tech_rep := seq_len(.N), by=c(groups[["assayMap"]])]
if (max(mathews_griner[["tech_rep"]]) > 1) {
    groups[["colDataMap"]] <- c(groups[["colDataMap"]], "tech_rep")
    groups[["assayMap"]] <- c(groups[["assayMap"]], "tech_rep")
} else {
    # delete the additional column if not needed
    message("No technical replicates in this dataset!")
    mathews_griner[["tech_reps"]] <- NULL
}
```

## Using the `TREDataMapper`

Once we are confident we know which columns are needed to uniquely
identify our treatments and samples, we can create a `TREDataMapper` using
our raw data and our mapping hypothesis. The `guessMapping` method does
the necessary internal work to map additional columns in your dataset to
the appopriate category&mdash;treatment metadata, sample metadata or assay
data&mdash;and returns the column names for each.

```{r}
(treMapper <- TREDataMapper(rawdata=mathews_griner))
```

We know we have successfully mapped all of our data in the "unmapped" list
item in our guess has no columns names in it. If this is not the case, your
may have to refine your hypothesis to include additional information needed
to uniquely identify each observation in your dataset.

```{r}
guess <- guessMapping(treMapper, groups, subset=TRUE)
```

Once we have mapped all our columns, we can assign their names to the
`TREDataMapper` object and use it to construct the `TreatmentResponseExperiment`
we will use in downstream dose-response and synergy-antagonism modelling.

```{r}
metadataMap(treMapper) <- list(experiment_metadata=guess$metadata$mapped_columns)
rowDataMap(treMapper) <- guess$rowDataMap
colDataMap(treMapper) <- guess$colDataMap
assayMap(treMapper) <- list(raw=guess$assayMap)
```

## Creating a `TreatmentResponseExperiment`

`r pgx` includes the `metaConstruct` method to simplify creation of a
`TreatmentResponseExperiment` object. Simply call it on the `TREDataMapper` you
created previously to instantiate your object.

```{r}
(tre <- metaConstruct(treMapper))
```

## Normalizing Treatment Response

```{r}
raw <- tre[["raw"]]
raw[,
    viability := viability / .SD[treatment1dose == 0 & treatment2dose == 0, viability],
    by=c("treatment1id", "treatment2id", "sampleid", "tech_rep")
]
raw[, viability := pmax(0, viability)]
tre[["raw"]] <- raw
```

```{r}
tre[["raw"]][, range(viability)]
```

```{r}
bad_treatments <- tre[["raw"]][viability > 2, unique(treatment1id)]
```

```{r}
## TODO:: Debug warning message!
tre <- subset(tre, !(treatment1id %in% bad_treatments))
```

```{r}
tre[["raw"]][, range(viability)]
```

## Fitting Monotherapy Curves

```{r}
tre_qc <- tre |>
    endoaggregate(
        subset=treatment2dose == 0,
        assay="raw",
        target="mono_viability",
        mean_viability=pmin(1, mean(viability)),
        by=c("treatment1id", "treatment1dose", "sampleid")
    )
```


```{r}
tre_fit <- tre_qc |>
    endoaggregate(
        {
            fit <- logLogisticRegression(treatment1dose, mean_viability,
                viability_as_pct=FALSE)
            ic50 <- computeIC50(treatment1dose, Hill_fit=fit)
            aac <- computeAUC(treatment1dose, Hill_fit=fit)
            list(
                HS=fit[["HS"]],
                E_inf = fit[["E_inf"]],
                EC50 = fit[["EC50"]],
                Rsq=as.numeric(unlist(attributes(fit))),
                aac_recomputed=aac,
                ic50_recomputed=ic50
            )
        },
        assay="mono_viability",
        target="mono_profiles",
        enlist=FALSE,
        by=c("treatment1id", "sampleid"),
        nthread=2
    )
```


## Joining Monotherapy Curve Fits to Combinations

```{r}
tre_combo <- tre_fit |>
    endoaggregate(
        assay="raw",
        target="combo_viability",
        mean(viability),
        by=c("treatment1id", "treatment2id", "treatment1dose", "treatment2dose", "sampleid")
    )
```

```{r}
tre_combo <- tre_combo |>
    mergeAssays(
        x="combo_viability",
        y="mono_profiles",
        by=c("treatment1id", "sampleid")
    ) |>
    mergeAssays(
        x="combo_viability",
        y="mono_profiles",
        by.x=c("treatment2id", "sampleid"),
        by.y=c("treatment1id", "sampleid"),
        suffixes=c("_1", "_2")
    )
```


```{r}
tre_combo <- tre_combo |>
    endoaggregate(
        viability_1=.SD[treatment2dose == 0, mean_viability],
        assay="combo_viability",
        by=c("treatment1id", "treatment1dose", "sampleid")
    ) |>
    endoaggregate(
        viability_2=.SD[treatment1dose == 0, mean_viability],
        assay="combo_viability",
        by=c("treatment1id", "treatment2dose", "sampleid")
    )
```

## Compute Synergy Scores

```{r}
tre_synergy <- tre_combo |>
    endoaggregate(
        assay="combo_viability",
        HSA_ref=computeHSA(viability_1, viability_2),
        Bliss_ref=computeBliss(viability_1, viability_2),
        Loewe_ref=computeLoewe(
            treatment1dose, HS_1=HS_1, EC50_1=EC50_1, E_inf_1=E_inf_1,
            treatment2dose, HS_2=HS_2, EC50_2=EC50_2, E_inf_2=E_inf_2
        ),
        ZIP_ref=computeZIP(
            treatment1dose, HS_1=HS_1, EC50_1=EC50_1, E_inf_1=E_inf_1,
            treatment2dose, HS_2=HS_2, EC50_2=EC50_2, E_inf_2=E_inf_2
        ),
        by=assayKeys(tre_combo, "combo_viability"),
        nthread=2
    )
```

```{r}
tre_synergy <- tre_synergy |>
    endoaggregate(
        assay="combo_viability",
        HSA_score=HSA_ref - mean_viability,
        Bliss_score=Bliss_ref - mean_viability,
        Loewe_score=Loewe_ref - mean_viability,
        ZIP_score=ZIP_ref - mean_viability,
        by=assayKeys(tre_synergy, "combo_viability")
    )
```


```{r}
tre_zip <- tre_synergy |>
    endoaggregate(
        assay="combo_viability",
        subset=treatment2dose != 0,
        {
            zip_fit <- estimateProjParams(
                dose_to=treatment1dose,
                combo_viability=mean_viability,
                dose_add=unique(treatment2dose),
                EC50_add=unique(EC50_2),
                HS_add=unique(HS_2),
                E_inf_add=unique(E_inf_2),
                residual="normal"
            )
            setNames(zip_fit, paste0(names(zip_fit), "_2_to_1"))
        },
        enlist=FALSE,
        by=c("treatment1id", "treatment2id", "treatment2dose", "sampleid"),
        nthread=2
    )
tre_zip <- tre_zip |>
    endoaggregate(
        assay="combo_viability",
        subset=treatment1dose != 0,
        {
            zip_fit <- estimateProjParams(
                dose_to=treatment2dose,
                combo_viability=mean_viability,
                dose_add=unique(treatment1dose),
                EC50_add=unique(EC50_1),
                HS_add=unique(HS_1),
                E_inf_add=unique(E_inf_1),
                residual="normal"
            )
            setNames(zip_fit, paste0(names(zip_fit), "_1_to_2"))
        },
        enlist=FALSE,
        by=c("treatment1id", "treatment2id", "treatment1dose", "sampleid"),
        nthread=2
    )
```

```{r}
tre_zip1 <- tre_zip |>
    endoaggregate(
        assay="combo_viability",
        ZIP_delta=.deltaScore(
            EC50_1_to_2=EC50_proj_1_to_2, EC50_2_to_1=EC50_proj_2_to_1,
            EC50_1=EC50_1, EC50_2=EC50_2,
            HS_1_to_2=HS_proj_1_to_2, HS_2_to_1=HS_proj_2_to_1,
            HS_1=HS_1, HS_2=HS_2,
            E_inf_2_to_1=E_inf_proj_2_to_1, E_inf_1_to_2=E_inf_proj_1_to_2,
            E_inf_1=E_inf_1, E_inf_2=E_inf_2,
            treatment1dose=treatment1dose, treatment2dose=treatment2dose,
            ZIP=ZIP_ref
        ),
        by=assayKeys(tre_zip, "combo_viability")
    )
```

## Visualizing Drug Synergy

```{r}
combo_viab <- tre_zip1[["combo_viability"]]
top_15_combo <- combo_viab[
    Rsq_1 > 0.5 & Rsqr_1_to_2 > 0.5 & Rsqr_2_to_1 > 0.5,
    .(delta=max(ZIP_delta, na.rm=TRUE)),
    by=.(treatment1id, treatment2id, sampleid)
][
    order(-delta),
    unique(.SD),
    .SDcols=c('treatment1id', 'treatment2id', 'sampleid', 'delta')
][1:15]
top_15_combo_df <- combo_viab[top_15_combo, on=c('treatment1id', 'treatment2id', 'sampleid')]
```

```{r}
# Last observation carried forward for NA/NaN delta scores, to make plot look nicer
setnafill(top_15_combo_df, type="locf", cols="ZIP_delta")
```

```{r, eval=FALSE, include=FALSE}
top_15_combo_df |>
    ggplot(aes(x=treatment1dose, y=treatment2dose, z=ZIP_delta * 100)) +
    scale_x_log10(oob=scales::squish_infinite) +
    scale_y_log10(oob=scales::squish_infinite) +
    geom_contour_filled() +
    facet_wrap(~ treatment1id, nrow=3, ncol=5) +
    scale_fill_brewer(palette="RdBu", direction=-1)
```

```{r}
top_15_combo_df |>
    ggplot(aes(x=factor(treatment1dose), y=factor(treatment2dose))) +
    geom_tile(aes(fill=ZIP_delta * 100)) +
    facet_wrap(~treatment1id, nrow=3, ncol=5) +
    scale_fill_gradient2(low="blue", mid="white", high="red", midpoint=0)
```

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References {.unnumbered}