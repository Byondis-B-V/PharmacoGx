---
title: "The LongTable Class"
author:
- name: Petr Smirnov
  affiliation: &pm Princess Margaret Cancer Centre, University Health Network, Toronto Canada
  email: petr.smirnov@uhnresearch.ca
- name: Christopher Eeles
  affiliation: *pm
  email: christopher.eeles@uhnresearch.ca
package: PharmacoGx
output:
  BiocStyle::html_document
vignette: |
  %\VignetteIndexEntry{The LongTable Class}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# The LongTable Class

```{r dependencies, include=FALSE}
library(PharmacoGx)
library(data.table)
```

## Why Do We Need A New Class?

The current implementation for the `@sensitivy` slot in a `PharmacoSet` has some
limitations.

Firstly, it does not natively support dose-response experiments with
multiple drugs and/or cancer cell lines. As a result we have not been 
able to include this data into a PharmacoSet thus far.

Secondly, drug combination data has the potential to scale to high dimensionality. 
As a result we need an object that is highly performant to ensure
computations on such data can be completed in a timely manner.

To resolve these issues Petr began designing a new class, the `long.array`, to
support drug combination data. My work over the last month has been adapting the
`long.array` concept into what I have tentatively dubbed the `LongTable`.


## Design Philosophy

While the current use case for this object is for supporting drug and cell-line
combinations in `PharmacoGx`, I wanted to create something flexible enough to fit
other use cases. As such, the current class makes no mention of drugs or cell-line,
nor anything specifically related to Bioinformatics or Computation Biology.

Rather, I tried to design and general purpose data structure which could support
high dimensional data for any use case. The current design takes the best aspects
of the `SummarizedExperiment` and `MultiAssayExperiment` class and implements 
them using the `data.table` package, which provides an R API to a rich set of 
tools for high performance data processing implemented in C.

## Anatomy of a LongTable

```{r fig1, fig.cap='LongTable Class Diagram', fig.wide=TRUE, echo=FALSE}
knitr::include_graphics('LongTableClassDiagramNonTransparent.svg')
```

For those acquainted with the `SummarizedExperiment`, this class diagram
should look very familiar. Indeed we have borrowed directly from that class
for the `rowData`, `colData`, `metadata` and `assays` slot names, and also 
implement the same accessors generics for the `LongTable` class.
As a result this object should be intuitive to work with for current `PharmacoGx`
users.

There are, however, some important differences which make this object more
flexible when dealing with high dimensional data.

```{r fig2, fig.cap='LongTable Structure and Cardinality', fig.wide=TRUE, echo=FALSE}
knitr::include_graphics('LongTableStructureNonTransparent.svg')
```

Here we see the that unlike a `SummarizedExperiment`, there are three distinct 
classes of columns in `rowData` and `colData`. The first is the `rowKey` or 
`colKey`, these are implemented internally to keep mappings between each assay
and the associated samples or drugs; these will not be returned by the accessors
by default. The second are the `rowIDs` and `colID`, these hold all of the 
information necessary to uniquely identify a row or column and are used to 
generate the `rowKey` and `colKey`. Finally, there are the `rowMeta` and `colMeta`
columns, which store any additional data about samples or drugs not required
to uniquely identify a row in either table.

Within the assays the `rowKey` and `colKey` are combined to form a primary key
for each assay row. This is required because each assay is stored in 'long' 
format, instead of wide format as in the assay matrices within a 
`SummarizedExperiment`. Thanks to the fast implementation of binary search
within the `data.table` package, assay tables can scale up to tens or even
hundreds of millions of rows while still being relatively performant.

Also worth noting is the cardinality between `rowData` and `colData` for a given
assay within the assays list. As indicated by the lower connection between these
tables and an assay, for each row or column key there may be zero or more rows in
the assay table. Conversely for each row in the assay there may be zero or one key
in `colData` or `rowData`. When combined, the `rowKey` and `colKey` for a given
row in an assay become a composite key which maps that to


## Building a LongTable

The current implementation of the `buildLongTable` function is able to assemble
a `LongTable` object from two sources. The first is a single large table with
all assays, row and column data contained within it.

This is the structure of the Merck drug combination data that has been used to
test the data structure thus far.

```{r head_data}
filePath <- '../data/drug_combo_merck.csv'
merckDT <- fread(filePath, na.strings=c('NULL'))
head(merckDT)
```
We can see here all the data related to the treatment response experiment is
contained within this table. To build a `LongTable` object from this file:

```{r build_from_single_table_file}
rowDataCols <- list(c(cell_line1="cell_line", BatchID="BatchID"))
colDataCols <- list(c(drug1='drugA_name', drug2='drugB_name',
    drug1dose='drugA Conc (µM)', drug2dose='drugB Conc (µM)'), c(comboName='combination_name'))
assayCols <- list(viability=paste0('viability', seq_len(4)),
                  viability_summary=c('mu/muMax', 'X/X0'))
longTable <- buildLongTable(from=filePath, rowDataCols, colDataCols, assayCols)
longTable
```
This function will also work if directly passed a `data.table` or `data.frame`
object:

```{r from_single_table}
longTable1 <- buildLongTable(from=merckDT, rowDataCols, colDataCols, assayCols)
all.equal(longTable, longTable1)
```
The second option for building a `LongTable` is to pass it a list of different
assays with a shared set of row and column identifiers. I haven't had a chance
to testing this functionality with real data yet, but do have a toy example.

```{r from_list_of_tables}
assayList <- assays(longTable, withDimnames=TRUE, metadata=TRUE)
assayList$new_viability <- assayList$viability  # Add a fake additional assay
assayCols$new_viability <-  assayCols$viability  # Add column names for fake assay
longTable2 <- buildLongTable(from=assayList, lapply(rowDataCols, names), lapply(colDataCols, names), assayCols)
longTable2
```
## LongTable Object

As mentioned previously, a `LongTable` has both list and table like behaviours.
For table like operations, a given `LongTable` can be thought of as a `rowKey`
by `colKey` rectangular object. To support `data.frame` like subsetting for this
object, the constructor makes pseudo row and column names, which are the ID columns
for each row of `rowData` or `colData` pasted together with a ':'.

### Row and Column Names

```{r rownames}
head(rownames(longTable))
```
We see that the rownames for the Merck `LongTable` are the cell line name
pasted to the batch id.

```{r colnames}
head(colnames(longTable))
```

For the column names, a similar pattern is followed by combining the colID 
columns in the form 'drug1:drug2:drug1dose:drug2dose'.

### `data.frame` Subsetting

We can subset a `LongTable` using the same row and column name syntax as 
with a `data.frame` or `matrix`.

```{r subset_dataframe_character}
row <- rownames(longTable)[1]
columns <- colnames(longTable)[1:2]
longTable[row, columns]
```
However, unlike a `data.frame` or `matrix` this subsetting also accepts partial
row and column names as well as regex queries.

```{r rowdata_coldata}
head(rowData(longTable), 3)
head(colData(longTable), 3)
```

For example, if we want to get all instance where '5-FU' is the drug:

```{r simple_regex}
longTable[, '5-FU']
```

This has matched all colnames where 5-FU was in either drug1 or drug2. If
we only want to match drug1, we have several options:

```{r column_specific_regex}
all.equal(longTable[, '5-FU:*:*:*'], longTable[, '^5-FU'])
```

### `data.table` Subsetting

In addition to regex queries, a `LongTable` object supports arbitrarily complex
subset queries using the `data.table` API. To access this API, you will need to 
use the `.` function, which allows you to pass raw R expressions to be evaluated
inside the `i` and `j` arguments for `dataTable[i, j]`.

For example if I want to subset to rows where the cell line is VCAP and columns
where drug1 is Temozolomide and drug2 is either Lapatinib or Bortezomib:

```{r }
longTable[.(cell_line1 == 'VCAP'),  # row query
          .(drug1 == 'Temozolomide' & drug2 %in% c('Lapatinib', 'Bortezomib'))]  # column query
```
We can also invert matches or subset on other columns in `rowData` or `colData`:

```{r }
subLongTable <- 
  longTable[.(BatchID != 2),
            .(drug1 == 'Temozolomide' & drug2 != 'Lapatinib')]
```
To show that it works as expected:

```{r }
print(paste0('BatchID: ', paste0(unique(rowData(subLongTable)$BatchID), collapse=', ')))
print(paste0('drug2: ', paste0(unique(colData(subLongTable)$drug2), collapse=', ')))
```

### Aggregate Functions

One of the biggest strengths of using `data.table`s to store the assay data is
that we can access the powerful aggregation API.

```{r }

```
```{r }
stats <- longTable$viability[, list(var=rowVars(as.matrix(.SD), na.rm=TRUE), mean=rowMeans(.SD, na.rm=TRUE))]

```

```{r }
# Join back to colIDs
colData(longTable)

```



































